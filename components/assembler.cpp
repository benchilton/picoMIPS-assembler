/*
 *  @name   assembler.h
 *  @date   04/02/2023
 *  @author bdc1g19
 *
 *
 */

/****************************** - Library Includes - *******************************/

#include <fstream>
#include <sstream>
#include <cmath>

/******************************** - User Includes - ********************************/

#include "includes/assembler.hpp"

/*********************************** - Defines - ***********************************/
/************************************ - Enums - ************************************/
/*********************************** - Classes - ***********************************/
/**************************** - Function Prototypes - ******************************/

std::size_t                  stringToSize_t(std::string str);
bool                         is_number(const std::string& s);

float                        stringToFloat( std::string str );
std::tuple<std::string, int> stringToFixedPoint( std::string str , size_t immediate_size );

std::string                  to_binary( ssize_t value , std::size_t bit_number );

/********************************* - Constants - ***********************************/
/********************************* - Variables - ***********************************/
/******************************* - Public Methods - ********************************/

assembler::assembler( std::string input_arch_info_loc , std::string source_assembly_loc , std::string in_output_dir )
          : lexer( source_assembly_loc )
{

  this->file_path_architecture_info = input_arch_info_loc;
  this->file_path_assembly_source   = source_assembly_loc;
  this->file_path_output            = in_output_dir;

  this->file_architecture_info.open(file_path_architecture_info);
  this->file_assembly_source.open(file_path_assembly_source);
  //this->file_output_verilog.open(file_path_output);
  try
  {
    this->architecture_data = nlohmann::json::parse(file_architecture_info);
  }
  catch (nlohmann::json::parse_error& e)
  {
    std::cout << "❌ JSON Parse error ❌" << std::endl;
    std::cout << " - cause: " << e.what() << std::endl;
  }

  this->file_architecture_info.close();
  if( this->architecture_data.end() == this->architecture_data.find("registers") )
  {
    std::cout << "❌Failed to find architecture information❌" << std::endl;
  }
  else
  {
    this->json_processing_thread = std::thread( &assembler::process_arch_json , this );
    this->json_processing_thread.join();
    this->file_assembly_source.close();
    std::cout << "assembling code with the following processor information:" << std::endl;
    JSON_neat_print( std::cout , "registers" , "");
    JSON_neat_print( std::cout , "instructions" , "" );
    JSON_neat_print( std::cout , "widths" , "" );

    std::cout << "branches : ";
    if( this->relative_branches == true )
    {
      std::cout << "relative 💀" << std::endl;
    }
    else
    {
      std::cout << "absolute" << std::endl;
    }

    std::cout << "Assembling code.." << std::endl;
    assemble_code();
    std::cout << "Performing clean up." << std::endl;
    std::filesystem::remove(".lexed_source.asm");
    std::cout << "Output file " << in_output_dir << " generated." << std::endl;
  }

}

/******************************* - Private Methods - *******************************/

void assembler::write_output_header()
{
  this->file_output_verilog << "//This file was generated by the picoMIPs assembler" << "\n";
  this->file_output_verilog << "//This tool was written by Benjamin Chilton" << "\n";
  this->file_output_verilog << "//Relevant architecture information:" << "\n";
  this->file_output_verilog << "//  - Branch type: " << this->architecture_data["branches"].get<std::string>() << "\n";
  this->file_output_verilog << "//  - Opcode length: " << this->opcode_size << "\n";
  this->file_output_verilog << "//  - Registers Address length: " << this->register_size << "\n";
  this->file_output_verilog << "//  - Jump Address length: " << this->address_size << "\n";
  this->file_output_verilog << "//  - Instruction length: " << this->instruction_size << "\n";
  this->file_output_verilog << "// HEX                          BINARY              Instruction in Assembly" << std::endl;
}

void assembler::write_output_footer()
{
}

void assembler::assemble_code()
{
    std::string line;
    std::string machine_code;
    this->file_assembly_source.open( ".lexed_source.asm" );
    this->file_output_verilog.open(file_path_output);
    this->current_line = 0;

    std::string machine_code_out;

    if( this->file_assembly_source.is_open() == true )
    {
      write_output_header();
      while ( this->file_assembly_source.eof() == false )
      {
        std::getline( this->file_assembly_source , this->line_contents );
        if( false == this->line_contents.empty() )
        {
          line = this->line_contents;
          auto converted = this->convert_machine_code( line );
        
          this->file_output_verilog << std::setw(this->instruction_size/4) <<
                  std::setfill('0') << std::hex << std::get<1>(converted);

          this->file_output_verilog << std::dec << "\t\t\t//Line: " <<  this->current_line << "\t" << std::get<0>(converted) << "\t\t\t" << this->line_contents << std::endl;
          this->current_line++;
        }
      }
      //This code pads the rest of the program memory so it fits into a power of 2 sized prog_mem
      size_t padding_lines = (1U << static_cast<size_t> (  ceilf(log2f(static_cast<float>(this->current_line))) ) );
      this->file_output_verilog << "//Wrote " << std::dec << this->current_line << " line of machine code." << std::endl;
      std::cout << "Padding lines: " << padding_lines << " a " << this->current_line << std::endl;
      this->file_output_verilog << "//Filling with " << padding_lines - this->current_line << " lines of NOPs" << std::endl ;
      auto no_op = this->convert_machine_code( "ADDI,$0,$0,0" );
      for (size_t i = 0; i < padding_lines - this->current_line; i++)
      {
        this->file_output_verilog << std::setw(this->instruction_size/4) <<
                  std::setfill('0') << std::hex << std::get<1>(no_op);

          this->file_output_verilog << "\t\t\t//" << std::get<0>(no_op) << "\t\t\t" << "ADDI,$0,$0,0" << std::endl;
      }
      
      //write_output_footer();
    }
    this->current_line = 0;
    this->file_output_verilog.close();
}


std::tuple<std::string, std::size_t> assembler::convert_machine_code( std::string line )
{
  size_t      pos = 0;
  size_t      iterations = 0;
  size_t      out_as_size_t = 0;
  size_t      shift_amount = this->instruction_size;
  std::string token;

  while( (pos != std::string::npos) && (line.empty() == false) )
  {
    pos = line.find(",",0);
    token = std::string(line , 0 , pos);
    line = line.erase(0 , pos + 1);

    auto processed_token = assembler_process_token( token , iterations );

    shift_amount -= std::get<0>(processed_token);
    out_as_size_t = out_as_size_t | ( std::get<1>(processed_token) << ( shift_amount ) );

    iterations++;
  }

  return std::make_tuple( to_binary(out_as_size_t , this->instruction_size) , out_as_size_t );
}

std::tuple<std::size_t, ssize_t> assembler::assembler_process_token( std::string token , size_t iterations )
{
  std::size_t return_width = 0;
  ssize_t out_as_size_t = 0;
  if( nullptr != this->architecture_data["registers"][token] )
  {
    return_width = this->register_size;
    out_as_size_t = static_cast<ssize_t>(this->architecture_data["registers"][token]) & (( 1 << this->opcode_size ) - 1);
  }
  if( nullptr != this->architecture_data["instructions"][token] )
  {
    return_width = this->opcode_size;
    out_as_size_t = static_cast<ssize_t>(this->architecture_data["instructions"][token]) & (( 1 << this->opcode_size ) - 1);
  }
  if( 0 == return_width )
  {
    nlohmann::json subroutines = this->lexer.get_subroutine_data();
    if( nullptr != subroutines[token] )
    {
      if(iterations > 2)
      {
        ssize_t value = 0;
        if(this->relative_branches == true)
        {
          value = subroutines[token].get<ssize_t>() - current_line - 1;
        }
        else
        {
          value = subroutines[token].get<ssize_t>() - 1;
        }
        out_as_size_t = value & (( 1U << this->immediate_size ) - 1);
        this->line_contents.insert( this->line_contents.find(token,0) , std::to_string(value) + " [" );
        this->line_contents.push_back(']');
        return_width = this->immediate_size;
      }
      else
      {
        this->line_contents.insert( this->line_contents.find(token,0) , std::to_string( subroutines[token].get<ssize_t>()) + " [" );
        this->line_contents.push_back(']');
        out_as_size_t = static_cast<ssize_t>(subroutines[token]) & (( 1U << this->address_size ) - 1);
        return_width = this->address_size;
      }
    }
    else if( true == is_number(token) )
    {
      //Jumps are just <Instruction> <ADDRESS>
      //Branches are <instruction> <reg> <reg> <offset>
      if(iterations > 2)
      {
        if( std::string::npos != token.find('.',0) )
        {
          auto token_fixed_point = stringToFixedPoint(token , this->immediate_size);

          return_width = this->immediate_size;
          out_as_size_t = std::get<1>(token_fixed_point) & (( 1U << this->immediate_size ) - 1);

        }
        else
        {
          out_as_size_t = static_cast<std::size_t>(stringToSize_t(token)) & (( 1U << this->immediate_size ) - 1);
          return_width = this->immediate_size;
        }
        
      }
      else
      {
          out_as_size_t = static_cast<std::size_t>(stringToSize_t(token));
          return_width = this->address_size;
      }
    }
    else
    {
      std::cout << "❌Unknown Token '" << token << "' in file❌" << std::endl;
    }
  }

  return std::make_tuple( return_width , out_as_size_t );
}

void assembler::process_arch_json()
{
  nlohmann::json architecture_info;
  auto register_data     = process_field("registers");
  auto instruction_data  = process_field("instructions");
  auto instruction_sizes = process_field("widths");
  auto branch_type       = this->architecture_data["branches"];

  if( (std::get<0>(register_data) == true) &&
      (std::get<0>(instruction_data) == true) && 
      (std::get<0>(instruction_sizes) == true) )
  {
      std::get<1>(register_data).update(std::get<1>(instruction_data));
      std::get<1>(register_data).update(std::get<1>(instruction_sizes));
      std::get<1>(register_data)["branches"] = branch_type;
      this->architecture_data = std::get<1>(register_data);
      this->fill_field_widths();

      if( this->architecture_data["branches"] == "absolute" )
      {
        this->relative_branches = false;
      }
      if( this->architecture_data["branches"] == "relative" )
      {
        this->relative_branches = true;
      }

  }
}

std::tuple<bool, nlohmann::json> assembler::process_field(std::string field )
{
  nlohmann::json processed_json;
  std::string current_key;
  std::string current_value;

  //Iterate through the field assembling the table of values
  for (auto& iter : architecture_data[field].items())
  {
      current_key   = iter.key();
      current_value = to_string(iter.value());

      /*Search in the key field for a -, this indicates a range*/
      if( std::string::npos == current_key.find("-") )
      {
        processed_json[field][ current_key ] = stringToSize_t(current_value);
      }
      else
      {
          //Remove whitespace and [] of the values
          current_value = assembler::remove_whitespace(current_value);
          current_value = current_value.erase( current_value.find("[") , 1  );
          current_value = current_value.erase( current_value.find("]") , 1  );
          current_key   = assembler::remove_whitespace(current_key);

          auto key_range   = json_extract_tokens( current_key , "-" );
          auto value_range = json_extract_tokens( current_value , "," );

          for (size_t idx = std::get<0>(key_range); idx <= std::get<1>(key_range); idx++)
          {
            processed_json[field][ std::get<2>(key_range) + std::to_string(idx) ] = std::get<0>(value_range) + idx;
          }
      }

  }
  return std::make_tuple(true , processed_json );
}

std::string assembler::remove_whitespace(std::string to_rm)
{
  while( std::string::npos != to_rm.find(" ") )
  {
    to_rm.erase(to_rm.find(" ") , 1);
  }
  return to_rm;
}

std::tuple<size_t, size_t, std::string> assembler::json_extract_tokens( std::string to_conv , std::string delim )
{
  size_t      lower_val = 10;
  size_t      upper_val = 10;
  std::string temp_string = to_conv.substr( to_conv.find(delim) + 1, to_conv.back() );
  temp_string = temp_string.substr( temp_string.find_first_of( "0123456789" ) , to_conv.find(delim) + 1 );
  upper_val = stringToSize_t( temp_string );

  temp_string = to_conv.substr( 0 , to_conv.find(delim) );
  temp_string = temp_string.substr( temp_string.find_first_of( "0123456789" , 0 ) , temp_string.find(delim) );
  lower_val = stringToSize_t( temp_string );

  std::string token_name = to_conv.substr( 0 , to_conv.find_first_of( "0123456789" ) );

  return std::make_tuple(lower_val , upper_val , token_name );
}

void assembler::fill_field_widths( void )
{
  nlohmann::json sizes = this->architecture_data["widths"];

  this->register_size    = std::ceil(std::log2( sizes["registers"].get<ssize_t>() ));
  this->opcode_size      = sizes["opcodes"].get<ssize_t>();
  this->immediate_size   = sizes["immediates"].get<ssize_t>();
  this->instruction_size = this->opcode_size + this->register_size + this->register_size + this->immediate_size;
  this->address_size     = this->instruction_size - this->opcode_size;
}

void assembler::JSON_neat_print( std::ostream& stream , std::string field , std::string line_start )
{
  //Iterate through the field assembling the table of values
  stream << line_start << field << ":" << std::endl;
  for (auto& iter : this->architecture_data[field].items())
  {
    stream << line_start << "\t - " << iter.key() << " : " << iter.value() << std::endl;
  }
}

/***************************** - Public Functions - ********************************/
/***************************** - Private Functions - *******************************/

std::size_t stringToSize_t(std::string str)
{
	std::stringstream sstream(str);
	size_t result;
	sstream >> result;
	return result;
}

float stringToFloat(std::string str)
{
	std::stringstream sstream(str);
	float result;
	sstream >> result;
	return result;
}

std::tuple<std::string, int> stringToFixedPoint( std::string str , size_t immediate_size )
{
  std::stringstream sstream(str);
	int result;
  sstream >> result;
  float string_as_float = stringToFloat(str);
  result = (int) (string_as_float * ( 1 << (immediate_size -1) ) );
  
  return std::make_tuple( to_binary( result , immediate_size ) , result );
}

bool is_number(const std::string& s)
{
    double d;
    std::istringstream is(s);
    is >> d;
    return !is.fail() && is.eof();
}


std::string to_binary( ssize_t value , std::size_t bit_number )
{
  std::string bin;
  bit_number = bit_number - 1;
  for( std::size_t idx = 0 ; idx <= bit_number ; idx++ )
  {
    bin.append(( (value >> (bit_number - idx) ) & 1 ) ? "1" : "0") ;
  }
  return bin;
}
